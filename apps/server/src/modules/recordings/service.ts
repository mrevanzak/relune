import { createOpenAI } from "@ai-sdk/openai";
import { db } from "@relune/db";
import type { Recording } from "@relune/db/schema";
import { keywords, recordingKeywords, recordings } from "@relune/db/schema";
import { env } from "@relune/env";
import { generateText, experimental_transcribe as transcribe } from "ai";
import { count, desc, eq, isNull } from "drizzle-orm";
import { convertToM4a, needsConversion } from "@/shared/audio-converter";
import { getContentType, uploadAudioToStorage } from "@/shared/storage";
import { supabase } from "@/shared/supabase";

/**
 * Non-request-dependent business logic for recordings
 * Services accept primitives and return domain data (no Elysia Context)
 */

// Initialize OpenAI provider for transcription and keyword generation
const openai = createOpenAI({
	apiKey: env.OPENAI_API_KEY,
});

export type ListRecordingsOptions = {
	userId: string;
	limit: number;
	offset: number;
};

export type ListRecordingsResult = {
	recordings: Recording[];
	limit: number;
	offset: number;
};

export async function listRecordings({
	userId,
	limit,
	offset,
}: ListRecordingsOptions): Promise<ListRecordingsResult> {
	const results = await db
		.select()
		.from(recordings)
		.where(eq(recordings.userId, userId))
		.orderBy(desc(recordings.recordedAt))
		.limit(limit)
		.offset(offset);

	return { recordings: results, limit, offset };
}

export type GetRecordingOptions = {
	id: string;
	userId: string;
};

export type GetRecordingResult =
	| { recording: Recording; error: null }
	| { recording: null; error: "not_found" | "forbidden" };

export async function getRecording({
	id,
	userId,
}: GetRecordingOptions): Promise<GetRecordingResult> {
	const result = await db
		.select()
		.from(recordings)
		.where(eq(recordings.id, id))
		.limit(1);

	const recording = result[0];

	if (!recording) {
		return { recording: null, error: "not_found" };
	}

	if (recording.userId !== userId) {
		return { recording: null, error: "forbidden" };
	}

	return { recording, error: null };
}

/**
 * Get pending recordings that need transcription
 */
export async function getPendingRecordings(
	limit: number,
): Promise<Recording[]> {
	return await db
		.select()
		.from(recordings)
		.where(isNull(recordings.transcript))
		.orderBy(recordings.createdAt)
		.limit(limit);
}

/**
 * Download audio file from Supabase Storage
 */
async function downloadAudio(audioUrl: string): Promise<Uint8Array | null> {
	// Extract storage path from URL
	const url = new URL(audioUrl);
	const pathMatch = url.pathname.match(
		/\/storage\/v1\/object\/public\/audio\/(.+)/,
	);
	if (!pathMatch?.[1]) {
		// Try signed URL pattern or direct fetch
		const response = await fetch(audioUrl);
		if (!response.ok) return null;
		return new Uint8Array(await response.arrayBuffer());
	}

	const storagePath = pathMatch[1];
	const { data, error } = await supabase.storage
		.from("audio")
		.download(storagePath);

	if (error || !data) return null;
	return new Uint8Array(await data.arrayBuffer());
}

/**
 * Transcribe audio using OpenAI Whisper via AI SDK
 */
async function transcribeAudio(audioData: Uint8Array): Promise<string> {
	const { text } = await transcribe({
		model: openai.transcription("whisper-1"),
		audio: audioData,
	});

	return text;
}

/**
 * Generate keywords from transcript using GPT-4o-mini
 */
async function generateKeywords(transcript: string): Promise<string[]> {
	const { text } = await generateText({
		model: openai("gpt-4o-mini"),
		prompt: `Extract 3-5 keywords or key phrases from this transcript. Return only the keywords, one per line, no numbering or bullets.

Transcript:
${transcript}`,
	});

	return text
		.split("\n")
		.map((k) => k.trim())
		.filter((k) => k.length > 0 && k.length < 50);
}

/**
 * Save keywords to database
 */
async function saveKeywords(
	recordingId: string,
	keywordNames: string[],
): Promise<void> {
	for (const name of keywordNames) {
		// Upsert keyword
		const existing = await db
			.select()
			.from(keywords)
			.where(eq(keywords.name, name.toLowerCase()))
			.limit(1);

		let keywordId: string;

		if (existing[0]) {
			keywordId = existing[0].id;
		} else {
			const inserted = await db
				.insert(keywords)
				.values({ name: name.toLowerCase() })
				.returning({ id: keywords.id });
			const insertedKeyword = inserted[0];
			if (!insertedKeyword) continue;
			keywordId = insertedKeyword.id;
		}

		// Link to recording
		await db
			.insert(recordingKeywords)
			.values({
				recordingId,
				keywordId,
				isAutoGenerated: true,
			})
			.onConflictDoNothing();
	}
}

/**
 * Process a single recording: transcribe and generate keywords
 */
export async function processRecording(
	recording: Recording,
): Promise<{ success: boolean; error?: string }> {
	try {
		// Download audio
		const audioData = await downloadAudio(recording.audioUrl);
		if (!audioData) {
			return { success: false, error: "Failed to download audio" };
		}

		// Extract actual filename from storage URL (files may be converted to m4a)
		// URL format: .../recordings/{uuid}-{filename}.m4a
		const transcript = await transcribeAudio(audioData);

		// Generate keywords
		const keywordList = await generateKeywords(transcript);

		// Update recording with transcript
		await db
			.update(recordings)
			.set({
				transcript,
				updatedAt: new Date(),
			})
			.where(eq(recordings.id, recording.id));

		// Save keywords
		await saveKeywords(recording.id, keywordList);

		return { success: true };
	} catch (error) {
		const message = error instanceof Error ? error.message : "Unknown error";
		return { success: false, error: message };
	}
}

/**
 * Process pending recordings in batch
 */
export type ProcessPendingResult = {
	processed: number;
	remaining: number;
	errors: Array<{ id: string; error: string }>;
};

export async function processPendingRecordings(
	limit: number,
): Promise<ProcessPendingResult> {
	const pending = await getPendingRecordings(limit);
	const errors: Array<{ id: string; error: string }> = [];
	let processed = 0;

	await Promise.all(
		pending.map(async (recording) => {
			const result = await processRecording(recording);
			if (result.success) {
				processed++;
			} else {
				errors.push({
					id: recording.id,
					error: result.error || "Unknown error",
				});
			}
		}),
	);

	// Count remaining
	const remainingCountResult = await db
		.select({ count: count() })
		.from(recordings)
		.where(isNull(recordings.transcript));
	const remainingCount = remainingCountResult[0]?.count ?? 0;
	return {
		processed,
		remaining: remainingCount,
		errors,
	};
}

/**
 * Create a new recording from in-app recording upload
 */
export type CreateAppRecordingOptions = {
	userId: string;
	file: File;
	durationSeconds?: number;
	recordedAt?: Date;
};

export type CreateAppRecordingResult =
	| { recording: Recording; error: null }
	| { recording: null; error: string };

export async function createAppRecording({
	userId,
	file,
	durationSeconds,
	recordedAt,
}: CreateAppRecordingOptions): Promise<CreateAppRecordingResult> {
	try {
		// Read file content
		const fileContent = new Uint8Array(await file.arrayBuffer());

		// Convert to m4a if needed (opus, ogg, wav, etc.)
		let finalContent: Uint8Array<ArrayBufferLike> = fileContent;
		let finalFilename = file.name;
		if (needsConversion(file.name)) {
			const converted = await convertToM4a(fileContent, file.name);
			finalContent = converted.data;
			finalFilename = converted.filename;
		}

		const contentType = getContentType(finalFilename);

		// Upload to storage
		const uploadResult = await uploadAudioToStorage(
			finalFilename,
			finalContent,
			contentType,
		);

		if (uploadResult.error) {
			return { recording: null, error: `Upload failed: ${uploadResult.error}` };
		}

		// Create recording in database
		const result = await db
			.insert(recordings)
			.values({
				userId,
				audioUrl: uploadResult.url,
				durationSeconds: durationSeconds ?? null,
				fileSizeBytes: finalContent.length,
				recordedAt: recordedAt ?? new Date(),
				importSource: "app",
				originalFilename: file.name,
			})
			.returning();

		const recording = result[0];
		if (!recording) {
			return { recording: null, error: "Failed to create recording" };
		}

		return { recording, error: null };
	} catch (error) {
		const message = error instanceof Error ? error.message : "Unknown error";
		return { recording: null, error: message };
	}
}
