import {
  boolean,
  integer,
  pgEnum,
  pgTable,
  primaryKey,
  text,
  timestamp,
  unique,
  uuid,
} from "drizzle-orm/pg-core";

// Enums
export const languageEnum = pgEnum("language", ["en", "fr", "mixed"]);
export const importSourceEnum = pgEnum("import_source", ["app", "whatsapp"]);

// Users table - matches Supabase Auth ID
export const users = pgTable("users", {
  id: uuid("id").primaryKey(), // Matches Supabase Auth ID
  email: text("email").notNull().unique(),
  displayName: text("display_name"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Recordings table
export const recordings = pgTable("recordings", {
  id: uuid("id").primaryKey().defaultRandom(),
  userId: uuid("user_id")
    .notNull()
    .references(() => users.id),
  audioUrl: text("audio_url").notNull(),
  durationSeconds: integer("duration_seconds"),
  fileSizeBytes: integer("file_size_bytes"),
  transcript: text("transcript"),
  language: languageEnum("language"),
  recordedAt: timestamp("recorded_at").notNull(),
  importSource: importSourceEnum("import_source").default("app").notNull(),
  originalFilename: text("original_filename"),
  notes: text("notes"), // Optional text context from WhatsApp import
  // Archive-related fields
  senderId: uuid("sender_id").references(() => users.id), // Original sender (can differ from uploader)
  isArchived: boolean("is_archived").default(false).notNull(),
  archivedAt: timestamp("archived_at"),
  importedAt: timestamp("imported_at"), // When WhatsApp import happened
  importedById: uuid("imported_by_id").references(() => users.id), // Who performed the import
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Keywords table
export const keywords = pgTable("keywords", {
  id: uuid("id").primaryKey().defaultRandom(),
  name: text("name").notNull().unique(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Junction table for recordings and keywords
export const recordingKeywords = pgTable(
  "recording_keywords",
  {
    recordingId: uuid("recording_id")
      .notNull()
      .references(() => recordings.id, { onDelete: "cascade" }),
    keywordId: uuid("keyword_id")
      .notNull()
      .references(() => keywords.id, { onDelete: "cascade" }),
    isAutoGenerated: boolean("is_auto_generated").default(true).notNull(),
  },
  (t) => [primaryKey({ columns: [t.recordingId, t.keywordId] })]
);

// Sender mappings table - for WhatsApp import name-to-user mapping
export const senderMappings = pgTable(
  "sender_mappings",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: uuid("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }), // User who created this mapping
    externalName: text("external_name").notNull(), // Name from WhatsApp (e.g., "Sarah")
    mappedUserId: uuid("mapped_user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }), // Which user account it maps to
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (t) => [unique().on(t.userId, t.externalName)]
);

// User settings table
export const userSettings = pgTable("user_settings", {
  userId: uuid("user_id")
    .primaryKey()
    .references(() => users.id, { onDelete: "cascade" }),
  autoArchiveDays: integer("auto_archive_days"), // Days before auto-archive (null = disabled)
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Type exports
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;

export type Recording = typeof recordings.$inferSelect;
export type NewRecording = typeof recordings.$inferInsert;

export type Keyword = typeof keywords.$inferSelect;
export type NewKeyword = typeof keywords.$inferInsert;

export type RecordingKeyword = typeof recordingKeywords.$inferSelect;
export type NewRecordingKeyword = typeof recordingKeywords.$inferInsert;

export type SenderMapping = typeof senderMappings.$inferSelect;
export type NewSenderMapping = typeof senderMappings.$inferInsert;

export type UserSettings = typeof userSettings.$inferSelect;
export type NewUserSettings = typeof userSettings.$inferInsert;
